\documentclass[lang=cn]{elegantpaper}
\usepackage{listings}
\usepackage{hyperref}
\title{编译原理 -- 实验 1 - 词法分析}
\author{61519322 杨哲睿}
\date{\today}

\begin{document}

\maketitle

\tableofcontents


% 提交清单：
% - Mini语言的词法规则描述（正规式或正规文法）
% - 正规式或正规文法->NFA->DFA->minimized DFA的手工过程（拍照整理为word或pdf文档）
% - 词法分析程序
% - 测试用例文件和测试结果文件
% - 实验报告

% 选择语言：pascal
% 源语言： rust-lang

\section{引言}

\subsection{实验要求}

\begin{quote}
    选择一个你熟悉的程序设计语言，找到它的规范（referrence or standard）。在规范中找到其词法的BNF或正规式描述。
\end{quote}

\begin{remark}
    选择的程序设计语言为：\lstinline|pascal|（源语言），具体规范参考为 \hyperref{https://github.com/bonzini/flex/blob/master/examples/manual/pascal.lex}{}{}{Github-pascal词法的lex描述}。
\end{remark}

\begin{quotation}
    选择该语言的一个子集（能够构成一个mini的语言，该语言至少能够进行函数调用、控制流语句（分支或循环）、简单的运算和赋值操作。）给出该mini语言的词法的正规文法或正规式。
    
\end{quotation}

在这里，选择的mini语言关键字为：

\begin{lstlisting}[language=pascal]
and
begin
div
do
else
end
for
function
if
in
nil
not
of
procedure
program
repeat
set
then
to
until
var
while
\end{lstlisting}
与标识符一同识别。

relop 如下：

\begin{lstlisting}[language=pascal]
<= >= < > <> =
:=
..
+ - * /
\end{lstlisting}

界符 sep 如下：
\begin{lstlisting}[language=pascal]
[ ] ( )
, ; .
\end{lstlisting}

其他需要的基本词法单元如下：
\begin{enumerate}
    \item 数
    \item 字符串
\end{enumerate}

下面给出具体的词法规则描述。

\section{词法规则描述、Minimized-DFA 简化过程}

如图所示：


\section{词法分析程序}


\subsection{简述}

正如DFA的定义：描述DFA只需要五元组 $S = (K, \Sigma, f, S, Z)$。那么描述DFA中的状态
只需要状态转换函数：
$$
change_{S}(\mathrm{ch}) = f( S, \mathrm{ch})
$$
这适合于将函数作为第一公民的{\textbf{函数式编程}}来实现。同时，对于$change_S(\mathrm{ch})$
做出如下的约定：

\noindent $change_{S} (\mathrm {ch}) = $
\begin{enumerate}
    \item 若DFA中存在 $S' = f (S, \mathrm{ch})$ 那么输出为对应状态（的状态转换函数）
          即输出为$change{S'}$
    \item 若DFA中不存在这样的转换，那么若
        \subitem $S \in Z$ 输出 \lstinline|true|；
        \subitem $S \notin Z$ 输出 \lstinline|false|。
\end{enumerate}

例如：

\begin{example} 字符串的识别：

    正如上文所提到的，将手工简化好的DFA转换为代码，即为：

    \begin{lstlisting}[language=lisp,caption=Racket-lang 实现-用于匹配字符串的DFA定义]
; DFA -- string
(define StringSM
(let ([q? (lambda (ch) (char=? ch #\'))])
    (letrec ([s0 (lambda (ch) (cond
                                [(q? ch) s1]
                                [else #f]))]
             [s1 (lambda (ch) (cond
                                [(q? ch) s1]
                                [(char=? #\nul ch) #f]
                                [else s3]))]
             [s2 (lambda (ch) (cond
                                [(q? ch) s3]
                                [else #f]))]
             [s3 (lambda (ch) (cond
                                [(q? ch) s4]
                                [(char=? #\nul ch) #f]
                                [else s3]))]
             [s4 (lambda (ch) (cond
                                [(q? ch)s3]
                                [else #t]))])
    s0)))
    \end{lstlisting}

    与此同时，为了运行该自动机，完成了\lstinline|iter-until-fail|函数，该函数的作用是
    在给定的符号列上运行DFA，直到DFA无法识别当前符号时停止。

    \begin{lstlisting}[language=lisp, caption=在给定的符号列上，运行该状态机]
(define (iter-until-fail s l)
  (let* ([ch (if (empty? l)
                 #\null
                 (first l))] ; getch --> ch
         [t (s ch)])         ; transition {s --[ch]-> t}
    (if (boolean? t)         ; stop?
        (if t
            (list)           ; '()  -> accept
            (void))          ; void -> fail
        (let ([result (iter-until-fail t (rest l))])
          (if (void? result)
              (void)         ; -> fail matching
              (cons ch result))
          ))))
    \end{lstlisting}
\end{example}

\subsection{实现细节}

\subsubsection{标识符-关键字的特殊处理}

\subsubsection{数组大小约定的数字识别 -- 向前看}

\subsection{测试用例和测试结果}

\section{总结}

\end{document}